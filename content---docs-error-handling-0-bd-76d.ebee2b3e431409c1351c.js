(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{48:function(e,r,n){"use strict";n.r(r),n.d(r,"frontMatter",function(){return s}),n.d(r,"rightToc",function(){return i}),n.d(r,"default",function(){return l});n(0);var t=n(58);function o(){return(o=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}function a(e,r){if(null==e)return{};var n,t,o=function(e,r){if(null==e)return{};var n,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)n=a[t],r.indexOf(n)>=0||(o[n]=e[n]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)n=a[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s={id:"error_handling",title:"Error Handling"},i=[{value:"The four ways a repeater can error",id:"the-four-ways-a-repeater-can-error",children:[{value:"1. Calling stop with an error",id:"1-calling-stop-with-an-error",children:[]},{value:"2. Calling the throw method",id:"2-calling-the-throw-method",children:[]},{value:"3. The executor throws an error",id:"3-the-executor-throws-an-error",children:[]},{value:"4. A promise passed to the push function rejects",id:"4-a-promise-passed-to-the-push-function-rejects",children:[]}]}],c={rightToc:i},p="wrapper";function l(e){var r=e.components,n=a(e,["components"]);return Object(t.b)(p,o({},c,n,{components:r,mdxType:"MDXLayout"}),Object(t.b)("p",null,"Because error handling is important for creating robust applications, repeaters are designed to catch and propagate any errors they receive in a predictable fashion. Every promise which is passed to a repeater is preemptively caught using ",Object(t.b)("inlineCode",{parentName:"p"},"Promise.prototype.catch")," to prevent unhandled rejections, and the errors are forwarded to the iterator methods ",Object(t.b)("inlineCode",{parentName:"p"},"next"),"/",Object(t.b)("inlineCode",{parentName:"p"},"return"),"/",Object(t.b)("inlineCode",{parentName:"p"},"throw")," so repeater consumers can handle them."),Object(t.b)("h2",{id:"the-four-ways-a-repeater-can-error"},"The four ways a repeater can error"),Object(t.b)("h3",{id:"1-calling-stop-with-an-error"},"1. Calling ",Object(t.b)("inlineCode",{parentName:"h3"},"stop")," with an error"),Object(t.b)("p",null,"The most common way to cause a repeater to error is to pass an argument to the ",Object(t.b)("inlineCode",{parentName:"p"},"stop")," function:"),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),'\nconst chan = new Repeater((push, stop) => {\n  for (let i = 0; i < 100; i++) {\n    push(i);\n  }\n  stop(new Error("Stop in the name of love üòò"));\n});\n\n(async () => {\n  try {\n    console.log(await chan.next()); // { value: 0, done: true }\n    console.log(await chan.next()); // { value: 1, done: true }\n    console.log(await chan.next()); // { value: 2, done: true }\n    // This line throws an error.\n    console.log(await errorChan().return());\n  } catch (err) {\n    console.log(err); // Error: Stop in the name of love üòò\n  } finally {\n    console.log(await chan.next()); // { done: true }\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(t.b)("p",null,"When ",Object(t.b)("inlineCode",{parentName:"p"},"stop")," is called with an error, values which were previously pushed can continue to be pulled. When there are no more values, the final call to ",Object(t.b)("inlineCode",{parentName:"p"},"next")," rejects with the error. If the repeater is ended prematurely with the ",Object(t.b)("inlineCode",{parentName:"p"},"return")," method, the repeater drops any remaining values and rejects with the error."),Object(t.b)("p",null,"As you can see in the example above, repeaters error only once before entering a finished state where all calls to ",Object(t.b)("inlineCode",{parentName:"p"},"next")," resolve to ",Object(t.b)("inlineCode",{parentName:"p"},"{ done: true }"),". This mirrors the behavior of async generator objects. Because repeaters can only be stopped once, only the first call to ",Object(t.b)("inlineCode",{parentName:"p"},"stop")," has an effect on the repeater, and any errors passed in subsequent calls to ",Object(t.b)("inlineCode",{parentName:"p"},"stop")," are dropped."),Object(t.b)("h3",{id:"2-calling-the-throw-method"},"2. Calling the ",Object(t.b)("inlineCode",{parentName:"h3"},"throw")," method"),Object(t.b)("p",null,"The async iterator interface defines an optional ",Object(t.b)("inlineCode",{parentName:"p"},"throw")," method which allows consumers to throw errors into the iterator. With async generators, yield statements can be wrapped in a ",Object(t.b)("inlineCode",{parentName:"p"},"try")," block to catch these errors. Repeaters implement the throw method, but don‚Äôt have any methods for recovering from errors thrown in."),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),'const chan = Repeater((push, stop) => {\n  for (let i = 0; i < 10; i++) {\n    push(i);\n  }\n});\n\n(async () => {\n  try {\n    const next = chan.next();\n    // this line does not throw because there is a pending call to next\n    console.log(await chan.throw("This error is passed to next üìû")); // { done: true } \n    // this line throws the error above\n    console.log(await next);\n  } catch (err) {\n    console.log(err); // Error: This error is passed to next üìû\n  } finally {\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(t.b)("p",null,"The ",Object(t.b)("inlineCode",{parentName:"p"},"throw")," method is equivalent to calling the ",Object(t.b)("inlineCode",{parentName:"p"},"stop")," function and ",Object(t.b)("inlineCode",{parentName:"p"},"return")," method in sequence, so ",Object(t.b)("inlineCode",{parentName:"p"},"throw")," blows away any pending values and finishes the repeater. Because ",Object(t.b)("inlineCode",{parentName:"p"},"throw")," rethrows errors if there are no pending calls to ",Object(t.b)("inlineCode",{parentName:"p"},"next"),", this method is of limited utility and mainly provided for compatability purposes."),Object(t.b)("h3",{id:"3-the-executor-throws-an-error"},"3. The executor throws an error"),Object(t.b)("p",null,"The repeater constructor catches both synchronous and asynchronous errors thrown by the executor."),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),'const chan = new Repeater((push, stop) => {\n  push("a");\n  push("b");\n  push("c");\n  // this error is dropped\n  stop(new Error("My error"));\n  // this error takes priority\n  throw new Error("This executor is busted ‚ò†Ô∏è");\n});\n\n(async () => {\n  try {\n    for await (const letter of chan) {\n      console.log(letter); // "a", "b", "c"\n    }\n  } catch (err) {\n    console.log(err); // Error: This executor is busted ‚ò†Ô∏è\n  } finally {\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(t.b)("p",null,"When an error occurs in the executor, the repeater is automatically stopped. Because errors which occur in the executor are usually indicative of a programming mistake, the error thrown by the executor takes precedence over errors passed via ",Object(t.b)("inlineCode",{parentName:"p"},"stop")," or ",Object(t.b)("inlineCode",{parentName:"p"},"throw"),", regardless of when they were passed to the repeater."),Object(t.b)("h3",{id:"4-a-promise-passed-to-the-push-function-rejects"},"4. A promise passed to the ",Object(t.b)("inlineCode",{parentName:"h3"},"push")," function rejects"),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),'const chan = new Repeater(async (push, stop) => {\n  await push("a");\n  await push("b");\n  await push("c");\n  await push(new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new Error("A rejection passed to push ‚è∞"));\n    }, 100);\n  }));\n  // these values are ignored\n  await push("e");\n  await push("f");\n  // these errors are ignored\n  stop(new Error("My error"));\n  throw new Error("this executor is busted");\n});\n\n(async () => {\n  try {\n    for await (const letter of chan) {\n      console.log(letter); // "a", "b", "c"\n    }\n  } catch (err) {\n    console.log(err); // Error: A rejection passed to push ‚è∞\n  } finally {\n    console.log(await chan.next()); // { done: true }\n  }\n})();\n')),Object(t.b)("p",null,"Repeaters unwrap promises and promise-like objects which are passed to ",Object(t.b)("inlineCode",{parentName:"p"},"push"),". If a promise passed to ",Object(t.b)("inlineCode",{parentName:"p"},"push")," rejects, the repeater finishes and any further pending values are dropped. The pushed rejection is like a time-bomb which blows up the repeater and prevents any more values from being pulled, regardless of when those values settled. A rejection which resolves before the repeater is stopped takes precedence over all other errors passed to repeaters. However, if a pushed rejection settles ",Object(t.b)("em",{parentName:"p"},"after")," the repeater has already stopped, the rejection is dropped and the repeater yields ",Object(t.b)("inlineCode",{parentName:"p"},"{ done: true }")," instead. This behavior is useful when creating ",Object(t.b)("a",o({parentName:"p"},{href:"inverted-repeaters"}),"inverted repeaters"),"."))}l.isMDXComponent=!0},58:function(e,r,n){"use strict";n.d(r,"a",function(){return i}),n.d(r,"b",function(){return h});var t=n(0),o=n.n(t),a=o.a.createContext({}),s=function(e){var r=o.a.useContext(a),n=r;return e&&(n="function"==typeof e?e(r):Object.assign({},r,e)),n},i=function(e){var r=s(e.components);return o.a.createElement(a.Provider,{value:r},e.children)};var c="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return o.a.createElement(o.a.Fragment,{},r)}},l=function(e){var r=e.components,n=e.mdxType,t=e.originalType,a=e.parentName,i=function(e,r){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===r.indexOf(t)&&(n[t]=e[t]);return n}(e,["components","mdxType","originalType","parentName"]),c=s(r),l=n,h=c[a+"."+l]||c[l]||p[l]||t;return r?o.a.createElement(h,Object.assign({},i,{components:r})):o.a.createElement(h,i)};function h(e,r){var n=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var a=n.length,s=new Array(a);s[0]=l;var i={};for(var p in r)hasOwnProperty.call(r,p)&&(i[p]=r[p]);i.originalType=e,i[c]="string"==typeof e?e:t,s[1]=i;for(var h=2;h<a;h++)s[h]=n[h];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}l.displayName="MDXCreateElement"}}]);